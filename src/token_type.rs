#[derive(Debug, PartialEq, Copy, Clone)]
pub enum TokenKind {
    // Utilities
    SingleLineComment,
    StartBlockComment,
    EndBlockComment,
    EOF,

    // Keywords
    Break,
    Case,
    Chan,
    Const,
    Continue,
    Default,
    Defer,
    Else,
    Fallthrough,
    For,
    Func,
    Go,
    Goto,
    If,
    Import,
    Interface,
    Map,
    Package,
    Range,
    Return,
    Select,
    Struct,
    Switch,
    Type,
    Var,

    // Operators and Punctuation
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Ampersand,
    Pipe,
    Caret,
    LessLess,
    GreaterGreater,
    AmpersandCaret,
    PlusEqual,
    MinusEqual,
    StarEqual,
    SlashEqual,
    PercentEqual,
    AmpersandEqual,
    PipeEqual,
    CaretEqual,
    LessLessEqual,
    GreaterGreaterEqual,
    AmpersandCaretEqual,
    AndAnd,
    PipePipe,
    LessMinus,
    PlusPlus,
    MinusMinus,
    EqualEqual,
    BangEqual,
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Equal,
    ColonEqual,
    Bang,
    DotDotDot,
    Dot,
    Colon,
    Comma,
    Semicolon,
    LeftParen,
    RightParen,
    LeftBracket,
    RightBracket,
    LeftBrace,
    RightBrace,
    // Literals
    // Identifier,
    // IntegerLiteral,
    // FloatLiteral,
    // ImaginaryLiteral,
    RuneLiteral,
    StringLiteral,
}

impl TokenKind {
    pub fn from_str(value: &str) -> Option<TokenKind> {
        match value {
            // Keywords
            "break" => Some(TokenKind::Break),
            "case" => Some(TokenKind::Case),
            "chan" => Some(TokenKind::Chan),
            "const" => Some(TokenKind::Const),
            "continue" => Some(TokenKind::Continue),
            "default" => Some(TokenKind::Default),
            "defer" => Some(TokenKind::Defer),
            "else" => Some(TokenKind::Else),
            "fallthrough" => Some(TokenKind::Fallthrough),
            "for" => Some(TokenKind::For),
            "func" => Some(TokenKind::Func),
            "go" => Some(TokenKind::Go),
            "goto" => Some(TokenKind::Goto),
            "if" => Some(TokenKind::If),
            "import" => Some(TokenKind::Import),
            "interface" => Some(TokenKind::Interface),
            "map" => Some(TokenKind::Map),
            "package" => Some(TokenKind::Package),
            "range" => Some(TokenKind::Range),
            "return" => Some(TokenKind::Return),
            "select" => Some(TokenKind::Select),
            "struct" => Some(TokenKind::Struct),
            "switch" => Some(TokenKind::Switch),
            "type" => Some(TokenKind::Type),
            "var" => Some(TokenKind::Var),
            // Operators and Punctuation
            "..." => Some(TokenKind::DotDotDot),
            "<<=" => Some(TokenKind::LessLessEqual),
            ">>=" => Some(TokenKind::GreaterGreaterEqual),
            "&^=" => Some(TokenKind::AmpersandCaretEqual),
            "+=" => Some(TokenKind::PlusEqual),
            "-=" => Some(TokenKind::MinusEqual),
            "*=" => Some(TokenKind::StarEqual),
            "/=" => Some(TokenKind::SlashEqual),
            "%=" => Some(TokenKind::PercentEqual),
            "&=" => Some(TokenKind::AmpersandEqual),
            "|=" => Some(TokenKind::PipeEqual),
            "^=" => Some(TokenKind::CaretEqual),
            "&&" => Some(TokenKind::AndAnd),
            "||" => Some(TokenKind::PipePipe),
            "<-" => Some(TokenKind::LessMinus),
            "++" => Some(TokenKind::PlusPlus),
            "--" => Some(TokenKind::MinusMinus),
            "==" => Some(TokenKind::EqualEqual),
            "!=" => Some(TokenKind::BangEqual),
            "<" => Some(TokenKind::Less),
            "<=" => Some(TokenKind::LessEqual),
            ">" => Some(TokenKind::Greater),
            ">=" => Some(TokenKind::GreaterEqual),
            ":=" => Some(TokenKind::ColonEqual),
            "<<" => Some(TokenKind::LessLess),
            ">>" => Some(TokenKind::GreaterGreater),
            "&^" => Some(TokenKind::AmpersandCaret),
            "!" => Some(TokenKind::Bang),
            "=" => Some(TokenKind::Equal),
            "+" => Some(TokenKind::Plus),
            "-" => Some(TokenKind::Minus),
            "*" => Some(TokenKind::Star),
            "/" => Some(TokenKind::Slash),
            "%" => Some(TokenKind::Percent),
            "&" => Some(TokenKind::Ampersand),
            "|" => Some(TokenKind::Pipe),
            "^" => Some(TokenKind::Caret),
            "." => Some(TokenKind::Dot),
            ":" => Some(TokenKind::Colon),
            "," => Some(TokenKind::Comma),
            ";" => Some(TokenKind::Semicolon),
            "(" => Some(TokenKind::LeftParen),
            ")" => Some(TokenKind::RightParen),
            "[" => Some(TokenKind::LeftBracket),
            "]" => Some(TokenKind::RightBracket),
            "{" => Some(TokenKind::LeftBrace),
            "}" => Some(TokenKind::RightBrace),
            _ => None,
        }
    }

    pub fn as_str(&self) -> &'static str {
        match self {
            TokenKind::Break => "break",
            TokenKind::Case => "case",
            TokenKind::Chan => "chan",
            TokenKind::Const => "const",
            TokenKind::Continue => "continue",
            TokenKind::Default => "default",
            TokenKind::Defer => "defer",
            TokenKind::Else => "else",
            TokenKind::Fallthrough => "fallthrough",
            TokenKind::For => "for",
            TokenKind::Func => "func",
            TokenKind::Go => "go",
            TokenKind::Goto => "goto",
            TokenKind::If => "if",
            TokenKind::Import => "import",
            TokenKind::Interface => "interface",
            TokenKind::Map => "map",
            TokenKind::Package => "package",
            TokenKind::Range => "range",
            TokenKind::Return => "return",
            TokenKind::Select => "select",
            TokenKind::Struct => "struct",
            TokenKind::Switch => "switch",
            TokenKind::Type => "type",
            TokenKind::Var => "var",
            TokenKind::EOF => "EOF",
            _ => "",
        }
    }

    pub fn is_tokenizeable(value: &str) -> bool {
        TokenKind::from_str(value).is_some()
    }

    pub fn could_match(input: &str) -> bool {
        const TOKENS: &[&str] = &[
            // Keywords
            "break",
            "case",
            "chan",
            "const",
            "continue",
            "default",
            "defer",
            "else",
            "fallthrough",
            "for",
            "func",
            "go",
            "goto",
            "if",
            "import",
            "interface",
            "map",
            "package",
            "range",
            "return",
            "select",
            "struct",
            "switch",
            "type",
            "var",
            // Operators and Punctuation
            "+",
            "-",
            "*",
            "/",
            "%",
            "&",
            "|",
            "^",
            "<<",
            ">>",
            "&^",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "&=",
            "|=",
            "^=",
            "<<=",
            ">>=",
            "&^=",
            "&&",
            "||",
            "<-",
            "++",
            "--",
            "==",
            "!=",
            "<",
            "<=",
            ">",
            ">=",
            "=",
            ":=",
            "!",
            "...",
            ".",
            ":",
            ",",
            ";",
            "(",
            ")",
            "[",
            "]",
            "{",
            "}",
        ];
        TOKENS.iter().any(|&t| t.starts_with(input))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn func_tokenizes() {
        let token = TokenKind::from_str("func");
        assert_eq!(token, Some(TokenKind::Func));
    }
}
